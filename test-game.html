<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¾™è™æ–— - æµ‹è¯•ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .game-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        .game-header {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-board {
            display: grid;
            grid-template-rows: repeat(5, 120px);
            grid-template-columns: repeat(4, 90px);
            gap: 10px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin: 20px auto;
            width: fit-content;
        }
        
        .board-cell {
            background: #ecf0f1;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .board-cell:hover:not(.empty-row) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        
        .board-cell.empty-row {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border-color: #34495e;
            cursor: default;
            opacity: 0.7;
        }
        
        .board-cell.empty-row::after {
            content: 'âš¡';
            font-size: 24px;
            color: rgba(255,255,255,0.3);
        }
        
        .card {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            position: relative;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .card.hidden {
            background-image: url('assets/cards/card_back.png') !important;
        }
        
        .card.revealed {
            color: #333;
            text-shadow: none;
        }
        
        .card.revealed.dragon {
            border: 2px solid #e74c3c;
        }
        
        .card.revealed.tiger {
            border: 2px solid #3498db;
        }
        
        .card.special::before {
            content: 'â­';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            color: gold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .card.selected {
            box-shadow: 0 0 15px #f39c12 !important;
            border: 3px solid #f39c12 !important;
        }
        
        .card-info {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            text-shadow: none;
        }
        
        .controls {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        .button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            font-size: 18px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .log {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
            text-align: left;
        }
        
        .debug-info {
            background: rgba(255,255,0,0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 12px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ‰ é¾™è™æ–— - æµ‹è¯•ç‰ˆ ğŸ…</h1>
        
        <div class="game-header">
            <div>
                <div>ğŸ‘¤ ç©å®¶</div>
                <div id="player-faction">æœªç¡®å®š</div>
            </div>
            <div class="status" id="game-status">ç‚¹å‡»å¼€å§‹æ¸¸æˆ</div>
            <div>
                <div>ğŸ¤– AIå¯¹æ‰‹</div>
                <div id="ai-faction">æœªç¡®å®š</div>
            </div>
        </div>
        
        <div id="game-board" class="game-board">
            <!-- æ£‹ç›˜æ ¼å­å°†ç”±JavaScriptç”Ÿæˆ -->
        </div>
        
        <div class="controls">
            <button id="start-btn" class="button">å¼€å§‹æ¸¸æˆ</button>
            <button id="restart-btn" class="button">é‡æ–°å¼€å§‹</button>
            <button id="debug-btn" class="button">è°ƒè¯•ä¿¡æ¯</button>
            <div class="status">å›åˆæ•°: <span id="turn-count">0</span> | å‰©ä½™ç‰Œæ•°: <span id="remaining-cards">16</span></div>
        </div>
        
        <div class="debug-info" id="debug-info">
            <strong>è°ƒè¯•ä¿¡æ¯:</strong><br>
            <div id="debug-content">æ¸¸æˆæœªå¼€å§‹</div>
        </div>
        
        <div class="log" id="game-log">
            <div>æ¸¸æˆæ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        </div>
    </div>

    <script type="module">
        import { GameEngine } from './scripts/core/GameEngine.js';
        
        class TestGame {
            constructor() {
                this.gameEngine = new GameEngine();
                this.selectedCell = null;
                this.isPlayerTurn = false;
                this.boardCells = [];
                this.init();
            }
            
            init() {
                this.createBoard();
                this.bindEvents();
                this.log('æµ‹è¯•ç‰ˆé¾™è™æ–—æ¸¸æˆå·²åˆå§‹åŒ–');
                this.updateDebugInfo();
            }
            
            createBoard() {
                const board = document.getElementById('game-board');
                board.innerHTML = '';
                this.boardCells = [];
                
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'board-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        if (row === 2) {
                            cell.classList.add('empty-row');
                        } else {
                            cell.addEventListener('click', () => this.handleCellClick(row, col));
                        }
                        
                        board.appendChild(cell);
                        this.boardCells.push(cell);
                    }
                }
            }
            
            bindEvents() {
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartGame());
                document.getElementById('debug-btn').addEventListener('click', () => this.toggleDebug());
            }
            
            async startGame() {
                this.log('ğŸ® å¼€å§‹æ–°æ¸¸æˆ...');
                
                try {
                    // å¼€å§‹æ¸¸æˆ
                    const result = this.gameEngine.startNewGame();
                    if (!result.success) {
                        this.log(`âŒ æ¸¸æˆå¯åŠ¨å¤±è´¥: ${result.error?.message}`);
                        return;
                    }
                    
                    this.log('âœ… æ¸¸æˆå¼•æ“å¯åŠ¨æˆåŠŸ');
                    
                    // ç³»ç»Ÿéšæœºå†³å®šå…ˆæ‰‹
                    const isPlayerFirst = Math.random() < 0.5;
                    this.gameEngine.gameState.currentPlayer = isPlayerFirst ? 'player' : 'ai';
                    this.log(`ğŸ¯ ç³»ç»Ÿåˆ†é…: ${isPlayerFirst ? 'ç©å®¶' : 'AI'}å…ˆæ‰‹`);
                    
                    // åˆå§‹åŒ–æ£‹ç›˜
                    const boardResult = this.gameEngine.initializeBoard();
                    if (!boardResult.success) {
                        this.log(`âŒ æ£‹ç›˜åˆå§‹åŒ–å¤±è´¥: ${boardResult.error?.message}`);
                        return;
                    }
                    
                    this.log('âœ… æ£‹ç›˜åˆå§‹åŒ–æˆåŠŸ');
                    this.renderBoard();
                    
                    this.isPlayerTurn = this.gameEngine.gameState.currentPlayer === 'player';
                    this.updateStatus();
                    this.updateDebugInfo();
                    
                    if (!this.isPlayerTurn) {
                        setTimeout(() => this.executeAITurn(), 1000);
                    }
                } catch (error) {
                    this.log(`âŒ å¯åŠ¨æ¸¸æˆæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
                }
            }
            
            renderBoard() {
                const gameState = this.gameEngine.gameState;
                
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (row === 2) continue;
                        
                        const cell = this.getCell(row, col);
                        const card = gameState.getCardAt(row, col);
                        
                        cell.innerHTML = '';
                        
                        if (card) {
                            const cardElement = document.createElement('div');
                            cardElement.className = 'card';
                            
                            if (card.isRevealed) {
                                cardElement.classList.add('revealed', card.faction);
                                
                                // è®¾ç½®æ­£é¢å›¾ç‰‡
                                const imagePath = \`assets/cards/\${card.faction}_\${card.level}.png\`;
                                cardElement.style.backgroundImage = \`url('\${imagePath}')\`;
                                
                                // æ·»åŠ å¡ç‰Œä¿¡æ¯
                                const infoDiv = document.createElement('div');
                                infoDiv.className = 'card-info';
                                infoDiv.textContent = card.name;
                                cardElement.appendChild(infoDiv);
                                
                                if (card.level === 1 || card.level === 8) {
                                    cardElement.classList.add('special');
                                }
                                
                                this.log(\`ğŸƒ æ¸²æŸ“å·²ç¿»å¼€å¡ç‰Œ: \${card.name} at (\${row}, \${col})\`);
                            } else {
                                cardElement.classList.add('hidden');
                                this.log(\`ğŸƒ æ¸²æŸ“èƒŒé¢å¡ç‰Œ at (\${row}, \${col})\`);
                            }
                            
                            cell.appendChild(cardElement);
                        }
                    }
                }
                
                this.updateStats();
                this.updateDebugInfo();
            }
            
            handleCellClick(row, col) {
                this.log(\`ğŸ” ç‚¹å‡»äº†ä½ç½® (\${row}, \${col})\`);
                
                if (!this.isPlayerTurn) {
                    this.log('âš ï¸ ç°åœ¨æ˜¯AIçš„å›åˆï¼Œè¯·ç­‰å¾…');
                    return;
                }
                
                const gameState = this.gameEngine.gameState;
                const card = gameState.getCardAt(row, col);
                
                if (!card) {
                    this.log('âš ï¸ è¿™é‡Œæ²¡æœ‰å¡ç‰Œ');
                    return;
                }
                
                this.log(\`ğŸƒ å¡ç‰Œè¯¦æƒ…: \${card.name} (\${card.faction}, Lv.\${card.level}) - \${card.isRevealed ? 'å·²ç¿»å¼€' : 'èƒŒé¢æœä¸Š'}\`);
                
                if (!card.isRevealed) {
                    // ç¿»ç‰Œ
                    this.log('ğŸ¯ å°è¯•ç¿»ç‰Œ...');
                    try {
                        const result = this.gameEngine.flipCard(row, col);
                        if (result.success) {
                            this.log(\`âœ… ç¿»ç‰ŒæˆåŠŸ! ç¿»å¼€äº† \${result.data.flippedCard.name} (\${result.data.flippedCard.faction})\`);
                            this.renderBoard();
                            this.updateStatus();
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡ç¿»ç‰Œï¼ˆå†³å®šé˜µè¥ï¼‰
                            if (gameState.playerFaction) {
                                this.log(\`ğŸ† ä½ çš„é˜µè¥: \${gameState.playerFaction === 'dragon' ? 'é¾™' : 'è™'}\`);
                            }
                            
                            this.endPlayerTurn();
                        } else {
                            this.log(\`âŒ ç¿»ç‰Œå¤±è´¥: \${result.error?.message || 'æœªçŸ¥é”™è¯¯'}\`);
                        }
                    } catch (error) {
                        this.log(\`âŒ ç¿»ç‰Œæ—¶å‘ç”Ÿé”™è¯¯: \${error.message}\`);
                    }
                } else if (card.faction === gameState.playerFaction) {
                    // é€‰æ‹©å·±æ–¹å¡ç‰Œ
                    this.log(\`ğŸ¯ é€‰æ‹©å·±æ–¹å¡ç‰Œ: \${card.name}\`);
                    this.selectCard(row, col);
                } else if (this.selectedCell) {
                    // æ”»å‡»æ•Œæ–¹å¡ç‰Œ
                    this.log(\`âš”ï¸ å°è¯•æ”»å‡»æ•Œæ–¹å¡ç‰Œ: \${card.name}\`);
                    this.attemptMove(row, col);
                } else {
                    this.log('ğŸ’¡ è¯·å…ˆé€‰æ‹©å·±æ–¹å¡ç‰Œï¼Œç„¶åå†æ”»å‡»æ•Œæ–¹å¡ç‰Œ');
                }
                
                this.updateDebugInfo();
            }
            
            selectCard(row, col) {
                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
                if (this.selectedCell) {
                    this.selectedCell.querySelector('.card')?.classList.remove('selected');
                }
                
                const cell = this.getCell(row, col);
                const cardElement = cell.querySelector('.card');
                if (cardElement) {
                    cardElement.classList.add('selected');
                    this.selectedCell = cell;
                    this.log(\`ğŸ¯ å·²é€‰æ‹©ä½ç½® (\${row}, \${col}) çš„å¡ç‰Œ\`);
                }
            }
            
            attemptMove(toRow, toCol) {
                if (!this.selectedCell) return;
                
                const fromRow = parseInt(this.selectedCell.dataset.row);
                const fromCol = parseInt(this.selectedCell.dataset.col);
                
                try {
                    const result = this.gameEngine.moveCard(fromRow, fromCol, toRow, toCol);
                    
                    if (result.success) {
                        this.log(\`ğŸš€ ç§»åŠ¨æˆåŠŸ: \${result.data.moveType}\`);
                        if (this.selectedCell) {
                            this.selectedCell.querySelector('.card')?.classList.remove('selected');
                            this.selectedCell = null;
                        }
                        this.renderBoard();
                        this.updateStatus();
                        
                        if (!result.data.isGameOver) {
                            this.endPlayerTurn();
                        }
                    } else {
                        this.log(\`âŒ ç§»åŠ¨å¤±è´¥: \${result.error?.message || 'æœªçŸ¥é”™è¯¯'}\`);
                    }
                } catch (error) {
                    this.log(\`âŒ ç§»åŠ¨æ—¶å‘ç”Ÿé”™è¯¯: \${error.message}\`);
                }
            }
            
            endPlayerTurn() {
                this.isPlayerTurn = false;
                this.log('ğŸ”„ ç»“æŸç©å®¶å›åˆï¼Œç­‰å¾…AI...');
                setTimeout(() => this.executeAITurn(), 1500);
            }
            
            async executeAITurn() {
                if (this.gameEngine.gameState.currentPlayer !== 'ai') {
                    this.log('âš ï¸ å½“å‰ä¸æ˜¯AIå›åˆ');
                    return;
                }
                
                this.log('ğŸ¤– AIæ­£åœ¨æ€è€ƒ...');
                
                try {
                    const result = await this.gameEngine.executeAITurn();
                    
                    if (result.success) {
                        this.log(\`ğŸ¤– AIæ‰§è¡Œäº†\${result.data.action}æ“ä½œ\`);
                        this.renderBoard();
                        this.updateStatus();
                        
                        if (!result.data.isGameOver) {
                            this.isPlayerTurn = true;
                            this.log('ğŸ”„ è½®åˆ°ç©å®¶å›åˆ');
                        }
                    } else {
                        this.log(\`âŒ AIæ‰§è¡Œå¤±è´¥: \${result.error || 'æœªçŸ¥é”™è¯¯'}\`);
                    }
                } catch (error) {
                    this.log(\`âŒ AIæ‰§è¡Œæ—¶å‘ç”Ÿé”™è¯¯: \${error.message}\`);
                }
                
                this.updateDebugInfo();
            }
            
            getCell(row, col) {
                const index = row * 4 + col;
                return this.boardCells[index];
            }
            
            updateStatus() {
                const gameState = this.gameEngine.gameState;
                const status = document.getElementById('game-status');
                const playerFaction = document.getElementById('player-faction');
                const aiFaction = document.getElementById('ai-faction');
                
                if (gameState.winner) {
                    status.textContent = \`æ¸¸æˆç»“æŸ - \${gameState.winner === 'player' ? 'ç©å®¶' : 'AI'}è·èƒœ!\`;
                } else {
                    status.textContent = \`\${gameState.currentPlayer === 'player' ? 'ä½ çš„' : 'AIçš„'}å›åˆ\`;
                }
                
                playerFaction.textContent = gameState.playerFaction ? 
                    (gameState.playerFaction === 'dragon' ? 'é¾™é˜µè¥' : 'è™é˜µè¥') : 'æœªç¡®å®š';
                aiFaction.textContent = gameState.aiFaction ? 
                    (gameState.aiFaction === 'dragon' ? 'é¾™é˜µè¥' : 'è™é˜µè¥') : 'æœªç¡®å®š';
            }
            
            updateStats() {
                const gameState = this.gameEngine.gameState;
                const revealedCount = gameState.cardsData.filter(card => card.isRevealed).length;
                
                document.getElementById('remaining-cards').textContent = 16 - revealedCount;
                document.getElementById('turn-count').textContent = gameState.gameLog.length;
            }
            
            updateDebugInfo() {
                const gameState = this.gameEngine.gameState;
                const debugContent = document.getElementById('debug-content');
                
                const debugInfo = \`
                    æ¸¸æˆé˜¶æ®µ: \${gameState.phase}<br>
                    å½“å‰ç©å®¶: \${gameState.currentPlayer}<br>
                    ç©å®¶é˜µè¥: \${gameState.playerFaction || 'æœªç¡®å®š'}<br>
                    AIé˜µè¥: \${gameState.aiFaction || 'æœªç¡®å®š'}<br>
                    å·²ç¿»å¼€å¡ç‰Œæ•°: \${gameState.cardsData.filter(c => c.isRevealed).length}/16<br>
                    æ¸¸æˆçŠ¶æ€: \${gameState.winner ? 'å·²ç»“æŸ - ' + gameState.winner + 'èƒœ' : 'è¿›è¡Œä¸­'}<br>
                    ç©å®¶å›åˆ: \${this.isPlayerTurn ? 'æ˜¯' : 'å¦'}
                \`;
                
                debugContent.innerHTML = debugInfo;
            }
            
            toggleDebug() {
                const debugInfo = document.getElementById('debug-info');
                debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
            }
            
            restartGame() {
                this.gameEngine = new GameEngine();
                this.selectedCell = null;
                this.isPlayerTurn = false;
                this.createBoard();
                this.log('ğŸ”„ æ¸¸æˆå·²é‡å¯');
                this.updateStatus();
                this.updateDebugInfo();
            }
            
            log(message) {
                const logElement = document.getElementById('game-log');
                const time = new Date().toLocaleTimeString();
                logElement.innerHTML += \`<div>[\${time}] \${message}</div>\`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        }
        
        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('DOMContentLoaded', () => {
            window.testGame = new TestGame();
        });
    </script>
</body>
</html>
