<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¾™è™æ–—æ¸¸æˆ - æµ‹è¯•è¿è¡Œå™¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .test-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 8px;
        }
        .test-button:hover {
            background: #0056b3;
        }
        .test-results {
            margin-top: 20px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        .test-success {
            border-left-color: #28a745;
        }
        .test-failure {
            border-left-color: #dc3545;
        }
        .test-item {
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
        }
        .test-summary {
            font-weight: bold;
            margin-top: 16px;
            padding: 12px;
            background: white;
            border-radius: 4px;
        }
        .progress {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: #007bff;
            transition: width 0.3s ease;
        }
        pre {
            background: #f1f3f4;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸ§ª é¾™è™æ–—æ¸¸æˆæµ‹è¯•å¥—ä»¶</h1>
            <p>Story S-01: åŸºç¡€æ¶æ„æµ‹è¯•</p>
        </div>

        <div class="test-controls">
            <button class="test-button" onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button class="test-button" onclick="runCardTests()">Cardç±»æµ‹è¯•</button>
            <button class="test-button" onclick="runGameStateTests()">GameStateç±»æµ‹è¯•</button>
            <button class="test-button" onclick="runGameEngineTests()">GameEngineç±»æµ‹è¯•</button>
            <button class="test-button" onclick="runBattleResolverTests()">BattleResolverç±»æµ‹è¯•</button>
            <button class="test-button" onclick="clearResults()">æ¸…ç©ºç»“æœ</button>
        </div>

        <div class="progress">
            <div class="progress-bar" id="test-progress" style="width: 0%"></div>
        </div>

        <div id="test-output" class="test-results">
            <p>ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...</p>
        </div>
    </div>

    <script type="module">
        import { Card } from '../scripts/core/Card.js';
        import { GameState } from '../scripts/core/GameState.js';
        import { GameEngine } from '../scripts/core/GameEngine.js';
        import { BattleResolver } from '../scripts/core/BattleResolver.js';

        // ç®€åŒ–çš„æµ‹è¯•æ¡†æ¶
        class TestFramework {
            constructor() {
                this.tests = [];
                this.currentDescribe = '';
                this.results = [];
            }

            describe(name, fn) {
                this.currentDescribe = name;
                fn();
            }

            test(name, fn) {
                this.tests.push({
                    describe: this.currentDescribe,
                    name,
                    fn
                });
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                    },
                    toEqual: (expected) => {
                        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                    },
                    toThrow: (expectedError) => {
                        try {
                            actual();
                            throw new Error(`Expected function to throw "${expectedError}"`);
                        } catch (error) {
                            if (!error.message.includes(expectedError)) {
                                throw new Error(`Expected error "${expectedError}", but got "${error.message}"`);
                            }
                        }
                    },
                    toBeDefined: () => {
                        if (actual === undefined) {
                            throw new Error('Expected value to be defined');
                        }
                    }
                };
            }

            async runTests(filter = null) {
                this.results = [];
                const testsToRun = filter ? this.tests.filter(filter) : this.tests;
                let passed = 0;
                let failed = 0;

                for (let i = 0; i < testsToRun.length; i++) {
                    const test = testsToRun[i];
                    const progress = Math.round(((i + 1) / testsToRun.length) * 100);
                    this.updateProgress(progress);

                    try {
                        await test.fn();
                        this.results.push({
                            status: 'pass',
                            describe: test.describe,
                            name: test.name
                        });
                        passed++;
                    } catch (error) {
                        this.results.push({
                            status: 'fail',
                            describe: test.describe,
                            name: test.name,
                            error: error.message
                        });
                        failed++;
                    }
                }

                return { passed, failed, total: passed + failed };
            }

            updateProgress(percent) {
                const progressBar = document.getElementById('test-progress');
                if (progressBar) {
                    progressBar.style.width = `${percent}%`;
                }
            }

            displayResults(summary) {
                const output = document.getElementById('test-output');
                const isSuccess = summary.failed === 0;
                
                output.className = `test-results ${isSuccess ? 'test-success' : 'test-failure'}`;
                
                let html = '';
                
                // æŒ‰describeåˆ†ç»„æ˜¾ç¤ºç»“æœ
                const groupedResults = {};
                this.results.forEach(result => {
                    if (!groupedResults[result.describe]) {
                        groupedResults[result.describe] = [];
                    }
                    groupedResults[result.describe].push(result);
                });

                Object.keys(groupedResults).forEach(describe => {
                    html += `<h3>${describe}</h3>`;
                    groupedResults[describe].forEach(result => {
                        const icon = result.status === 'pass' ? 'âœ…' : 'âŒ';
                        const className = result.status === 'pass' ? 'test-pass' : 'test-fail';
                        html += `<div class="test-item ${className}">
                            ${icon} ${result.name}
                            ${result.error ? `<br><small>é”™è¯¯: ${result.error}</small>` : ''}
                        </div>`;
                    });
                });

                html += `<div class="test-summary">
                    ğŸ“Š æµ‹è¯•ç»“æœ: ${summary.passed} é€šè¿‡, ${summary.failed} å¤±è´¥, æ€»è®¡ ${summary.total}
                    ${isSuccess ? '<br>ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼' : '<br>âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦ä¿®å¤ã€‚'}
                </div>`;

                output.innerHTML = html;
            }
        }

        // åˆ›å»ºå…¨å±€æµ‹è¯•å®ä¾‹
        const testFramework = new TestFramework();
        window.describe = testFramework.describe.bind(testFramework);
        window.test = testFramework.test.bind(testFramework);
        window.expect = testFramework.expect.bind(testFramework);

        // Cardç±»æµ‹è¯•
        describe('Card Class Tests', () => {
            test('åº”è¯¥æ­£ç¡®åˆ›å»ºé¾™é˜µè¥å¡ç‰Œ', () => {
                const card = new Card('dragon_3', 'dragon', 3);
                
                expect(card.id).toBe('dragon_3');
                expect(card.faction).toBe('dragon');
                expect(card.level).toBe(3);
                expect(card.name).toBe('é‡‘é¾™');
                expect(card.isRevealed).toBe(false);
                expect(card.owner).toBe(null);
                expect(card.position.row).toBe(-1);
                expect(card.position.col).toBe(-1);
            });

            test('åº”è¯¥æ­£ç¡®åˆ›å»ºè™é˜µè¥å¡ç‰Œ', () => {
                const card = new Card('tiger_5', 'tiger', 5);
                
                expect(card.id).toBe('tiger_5');
                expect(card.faction).toBe('tiger');
                expect(card.level).toBe(5);
                expect(card.name).toBe('å£•è™');
            });

            test('åº”è¯¥æ­£ç¡®ç”Ÿæˆå›¾ç‰‡è·¯å¾„', () => {
                const dragonCard = new Card('dragon_1', 'dragon', 1);
                const tigerCard = new Card('tiger_8', 'tiger', 8);
                
                expect(dragonCard.getImagePath()).toBe('assets/cards/dragon_1.png');
                expect(tigerCard.getImagePath()).toBe('assets/cards/tiger_8.png');
            });

            test('åº”è¯¥æ­£ç¡®æ‰§è¡Œæˆ˜æ–—é€»è¾‘', () => {
                const dragon5 = new Card('dragon_5', 'dragon', 5);
                const tiger3 = new Card('tiger_3', 'tiger', 3);
                const tiger5 = new Card('tiger_5', 'tiger', 5);
                
                expect(dragon5.battleWith(tiger3)).toBe('win');
                expect(tiger3.battleWith(dragon5)).toBe('lose');
                expect(dragon5.battleWith(tiger5)).toBe('draw');
            });

            test('åº”è¯¥æ­£ç¡®å¤„ç†ç‰¹æ®Šè§„åˆ™', () => {
                const dragonKing = new Card('dragon_1', 'dragon', 1);
                const tigerKing = new Card('tiger_1', 'tiger', 1);
                const transformDragon = new Card('dragon_8', 'dragon', 8);
                const kingTiger = new Card('tiger_8', 'tiger', 8);
                
                expect(kingTiger.battleWith(dragonKing)).toBe('win');
                expect(transformDragon.battleWith(tigerKing)).toBe('win');
            });
        });

        // GameStateç±»æµ‹è¯•
        describe('GameState Class Tests', () => {
            test('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€', () => {
                const gameState = new GameState();
                
                expect(gameState.phase).toBe('setup');
                expect(gameState.currentPlayer).toBe(null);
                expect(gameState.playerFaction).toBe(null);
                expect(gameState.aiFaction).toBe(null);
                expect(gameState.selectedPosition).toBe(null);
                expect(gameState.winner).toBe(null);
                expect(Array.isArray(gameState.gameLog)).toBe(true);
                expect(gameState.gameLog.length).toBe(0);
            });

            test('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–4x5æ£‹ç›˜', () => {
                const gameState = new GameState();
                const board = gameState.board;
                
                expect(board.length).toBe(5);
                expect(board[0].length).toBe(4);
                
                // æ£€æŸ¥ç¬¬3è¡Œä¸ºç©ºè¡Œ
                for (let col = 0; col < 4; col++) {
                    expect(board[2][col]).toBe(null);
                }
            });

            test('åº”è¯¥æ­£ç¡®åˆ›å»º16å¼ å¡ç‰Œ', () => {
                const gameState = new GameState();
                const cards = gameState.cardsData;
                
                expect(cards.length).toBe(16);
                
                const dragonCards = cards.filter(card => card.faction === 'dragon');
                const tigerCards = cards.filter(card => card.faction === 'tiger');
                
                expect(dragonCards.length).toBe(8);
                expect(tigerCards.length).toBe(8);
            });

            test('åº”è¯¥èƒ½æ­£ç¡®æ£€æŸ¥ä½ç½®æœ‰æ•ˆæ€§', () => {
                const gameState = new GameState();
                
                expect(gameState.isValidPosition(0, 0)).toBe(true);
                expect(gameState.isValidPosition(2, 1)).toBe(true);
                expect(gameState.isValidPosition(4, 3)).toBe(true);
                expect(gameState.isValidPosition(-1, 0)).toBe(false);
                expect(gameState.isValidPosition(0, 4)).toBe(false);
                expect(gameState.isValidPosition(5, 0)).toBe(false);
            });

            test('åº”è¯¥èƒ½æ­£ç¡®æ·»åŠ æ¸¸æˆæ—¥å¿—', () => {
                const gameState = new GameState();
                
                gameState.addLogEntry('flip', 'player', 'ç¿»å¼€å¡ç‰Œ', { cardId: 'dragon_3' });
                
                expect(gameState.gameLog.length).toBe(1);
                
                const logEntry = gameState.gameLog[0];
                expect(logEntry.type).toBe('flip');
                expect(logEntry.player).toBe('player');
                expect(logEntry.action).toBe('ç¿»å¼€å¡ç‰Œ');
                expect(logEntry.details.cardId).toBe('dragon_3');
                expect(logEntry.timestamp).toBeDefined();
                expect(logEntry.id).toBeDefined();
            });
        });

        // GameEngineç±»æµ‹è¯•
        describe('GameEngine Class Tests', () => {
            test('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–æ¸¸æˆå¼•æ“', () => {
                const gameEngine = new GameEngine();
                expect(gameEngine.gameState).toBeDefined();
                expect(gameEngine.battleResolver).toBeDefined();
                expect(gameEngine.gameId).toBeDefined();
            });

            test('åº”è¯¥èƒ½æ­£ç¡®å¼€å§‹æ–°æ¸¸æˆ', () => {
                const gameEngine = new GameEngine();
                const result = gameEngine.startNewGame();
                
                expect(result.success).toBe(true);
                expect(gameEngine.gameState.phase).toBe('rps');
            });

            test('åº”è¯¥èƒ½æ­£ç¡®æ‰§è¡ŒçŒœæ‹³æ“ä½œ', () => {
                const gameEngine = new GameEngine();
                gameEngine.startNewGame();
                
                const result = gameEngine.playRockPaperScissors('rock');
                
                expect(result.success).toBe(true);
                expect(result.data.playerChoice).toBe('rock');
                expect(['rock', 'paper', 'scissors']).toContain(result.data.aiChoice);
                expect(gameEngine.gameState.phase).toBe('playing');
            });
        });

        // BattleResolverç±»æµ‹è¯•
        describe('BattleResolver Class Tests', () => {
            test('åº”è¯¥æ­£ç¡®å¤„ç†åŸºç¡€ç­‰çº§æˆ˜æ–—', () => {
                const battleResolver = new BattleResolver();
                const dragon5 = new Card('dragon_5', 'dragon', 5);
                const tiger3 = new Card('tiger_3', 'tiger', 3);
                
                // è®¾ç½®ä¸ºå·²ç¿»å¼€çŠ¶æ€
                dragon5.isRevealed = true;
                tiger3.isRevealed = true;
                
                const result = battleResolver.resolveBattle(dragon5, tiger3);
                
                expect(result.winner).toBe('attacker');
                expect(result.eliminatedCards.length).toBe(1);
                expect(result.eliminatedCards[0]).toBe(tiger3);
            });

            test('åº”è¯¥æ­£ç¡®å¤„ç†ç‰¹æ®Šè§„åˆ™ï¼šå°ç‹è™vsé¾™ç‹', () => {
                const battleResolver = new BattleResolver();
                const kingTiger = new Card('tiger_8', 'tiger', 8);
                const dragonKing = new Card('dragon_1', 'dragon', 1);
                
                kingTiger.isRevealed = true;
                dragonKing.isRevealed = true;
                
                const result = battleResolver.resolveBattle(kingTiger, dragonKing);
                
                expect(result.winner).toBe('attacker');
                expect(result.reason).toContain('ç‰¹æ®Šè§„åˆ™');
            });

            test('åº”è¯¥æ­£ç¡®å¤„ç†åŒç­‰çº§æˆ˜æ–—', () => {
                const battleResolver = new BattleResolver();
                const dragon5 = new Card('dragon_5', 'dragon', 5);
                const tiger5 = new Card('tiger_5', 'tiger', 5);
                
                dragon5.isRevealed = true;
                tiger5.isRevealed = true;
                
                const result = battleResolver.resolveBattle(dragon5, tiger5);
                
                expect(result.winner).toBe('draw');
                expect(result.eliminatedCards.length).toBe(2);
            });
        });

        // å…¨å±€æµ‹è¯•å‡½æ•°
        window.runAllTests = async function() {
            console.log('ğŸ§ª å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...');
            const summary = await testFramework.runTests();
            testFramework.displayResults(summary);
            console.log('ğŸ“Š æµ‹è¯•å®Œæˆ:', summary);
        };

        window.runCardTests = async function() {
            console.log('ğŸƒ å¼€å§‹è¿è¡ŒCardç±»æµ‹è¯•...');
            const summary = await testFramework.runTests(test => test.describe === 'Card Class Tests');
            testFramework.displayResults(summary);
        };

        window.runGameStateTests = async function() {
            console.log('ğŸ® å¼€å§‹è¿è¡ŒGameStateç±»æµ‹è¯•...');
            const summary = await testFramework.runTests(test => test.describe === 'GameState Class Tests');
            testFramework.displayResults(summary);
        };

        window.runGameEngineTests = async function() {
            console.log('ğŸ® å¼€å§‹è¿è¡ŒGameEngineç±»æµ‹è¯•...');
            const summary = await testFramework.runTests(test => test.describe === 'GameEngine Class Tests');
            testFramework.displayResults(summary);
        };

        window.runBattleResolverTests = async function() {
            console.log('âš”ï¸ å¼€å§‹è¿è¡ŒBattleResolverç±»æµ‹è¯•...');
            const summary = await testFramework.runTests(test => test.describe === 'BattleResolver Class Tests');
            testFramework.displayResults(summary);
        };

        window.clearResults = function() {
            const output = document.getElementById('test-output');
            output.innerHTML = '<p>æµ‹è¯•ç»“æœå·²æ¸…ç©ºã€‚ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...</p>';
            output.className = 'test-results';
            const progressBar = document.getElementById('test-progress');
            progressBar.style.width = '0%';
        };

        console.log('ğŸ§ª æµ‹è¯•ç¯å¢ƒå·²å‡†å¤‡å°±ç»ª');
        console.log('ğŸ’¡ ä½¿ç”¨ runAllTests() å¼€å§‹æµ‹è¯•');
    </script>
</body>
</html>
